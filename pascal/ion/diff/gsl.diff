diff --git a/gsl/gsl_dft_complex.h b/gsl/gsl_dft_complex.h
new file mode 100644
index 0000000..cb4d088
--- /dev/null
+++ b/gsl/gsl_dft_complex.h
@@ -0,0 +1,55 @@
+/* fft/gsl_dft_complex.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_DFT_COMPLEX_H__
+#define __GSL_DFT_COMPLEX_H__
+
+#include <stddef.h>
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_complex.h>
+#include <gsl/gsl_fft.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+int gsl_dft_complex_forward (const double data[], const size_t stride, const size_t n,
+                             double result[]);
+
+int gsl_dft_complex_backward (const double data[], const size_t stride, const size_t n,
+                              double result[]);
+
+int gsl_dft_complex_inverse (const double data[], const size_t stride, const size_t n,
+                             double result[]);
+
+int gsl_dft_complex_transform (const double data[], const size_t stride, const size_t n,
+                     double result[], const gsl_fft_direction sign);
+
+__END_DECLS
+
+#endif /* __GSL_DFT_COMPLEX_H__ */
diff --git a/gsl/gsl_dft_complex_float.h b/gsl/gsl_dft_complex_float.h
new file mode 100644
index 0000000..c511ac0
--- /dev/null
+++ b/gsl/gsl_dft_complex_float.h
@@ -0,0 +1,55 @@
+/* fft/gsl_dft_complex_float.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_DFT_COMPLEX_FLOAT_H__
+#define __GSL_DFT_COMPLEX_FLOAT_H__
+
+#include <stddef.h>
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_complex.h>
+#include <gsl/gsl_fft.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+int gsl_dft_complex_float_forward (const float data[], const size_t stride, const size_t n,
+                             float result[]);
+
+int gsl_dft_complex_float_backward (const float data[], const size_t stride, const size_t n,
+                              float result[]);
+
+int gsl_dft_complex_float_inverse (const float data[], const size_t stride, const size_t n,
+                             float result[]);
+
+int gsl_dft_complex_float_transform (const float data[], const size_t stride, const size_t n,
+                     float result[], const gsl_fft_direction sign);
+
+__END_DECLS
+
+#endif /* __GSL_DFT_COMPLEX_FLOAT_H__ */
diff --git a/gsl/gsl_fft.h b/gsl/gsl_fft.h
new file mode 100644
index 0000000..8870a88
--- /dev/null
+++ b/gsl/gsl_fft.h
@@ -0,0 +1,51 @@
+/* fft/gsl_fft.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_FFT_H__
+#define __GSL_FFT_H__
+
+#include <gsl/gsl_complex.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+typedef enum
+  {
+    gsl_fft_forward = -1, gsl_fft_backward = +1   
+  }
+gsl_fft_direction;
+
+/* this gives the sign in the formula
+
+   h(f) = \sum x(t) exp(+/- 2 pi i f t) 
+       
+   where - is the forward transform direction and + the inverse direction */
+
+__END_DECLS
+
+#endif /* __GSL_FFT_H__ */
diff --git a/gsl/gsl_fft_complex.h b/gsl/gsl_fft_complex.h
new file mode 100644
index 0000000..c13f7ea
--- /dev/null
+++ b/gsl/gsl_fft_complex.h
@@ -0,0 +1,136 @@
+/* fft/gsl_fft_complex.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_FFT_COMPLEX_H__
+#define __GSL_FFT_COMPLEX_H__
+
+#include <stddef.h>
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_complex.h>
+#include <gsl/gsl_fft.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+/*  Power of 2 routines  */
+
+
+int gsl_fft_complex_radix2_forward (gsl_complex_packed_array data,
+                                    const size_t stride,
+                                    const size_t n);
+
+int gsl_fft_complex_radix2_backward (gsl_complex_packed_array data,
+                                     const size_t stride,
+                                     const size_t n);
+
+int gsl_fft_complex_radix2_inverse (gsl_complex_packed_array data,
+                                    const size_t stride,
+                                    const size_t n);
+
+int gsl_fft_complex_radix2_transform (gsl_complex_packed_array data,
+                                      const size_t stride,
+                                      const size_t n,
+                                      const gsl_fft_direction sign);
+
+int gsl_fft_complex_radix2_dif_forward (gsl_complex_packed_array data,
+                                        const size_t stride,
+                                        const size_t n);
+
+int gsl_fft_complex_radix2_dif_backward (gsl_complex_packed_array data,
+                                         const size_t stride,
+                                         const size_t n);
+
+int gsl_fft_complex_radix2_dif_inverse (gsl_complex_packed_array data,
+                                        const size_t stride,
+                                        const size_t n);
+
+int gsl_fft_complex_radix2_dif_transform (gsl_complex_packed_array data,
+                                          const size_t stride,
+                                          const size_t n,
+                                          const gsl_fft_direction sign);
+
+/*  Mixed Radix general-N routines  */
+
+typedef struct
+  {
+    size_t n;
+    size_t nf;
+    size_t factor[64];
+    gsl_complex *twiddle[64];
+    gsl_complex *trig;
+  }
+gsl_fft_complex_wavetable;
+
+typedef struct
+{
+  size_t n;
+  double *scratch;
+}
+gsl_fft_complex_workspace;
+
+
+gsl_fft_complex_wavetable *gsl_fft_complex_wavetable_alloc (size_t n);
+
+void gsl_fft_complex_wavetable_free (gsl_fft_complex_wavetable * wavetable);
+
+gsl_fft_complex_workspace *gsl_fft_complex_workspace_alloc (size_t n);
+
+void gsl_fft_complex_workspace_free (gsl_fft_complex_workspace * workspace);
+
+int gsl_fft_complex_memcpy (gsl_fft_complex_wavetable * dest,
+                            gsl_fft_complex_wavetable * src);
+
+
+int gsl_fft_complex_forward (gsl_complex_packed_array data,
+                             const size_t stride,
+                             const size_t n,
+                             const gsl_fft_complex_wavetable * wavetable,
+                             gsl_fft_complex_workspace * work);
+
+int gsl_fft_complex_backward (gsl_complex_packed_array data,
+                              const size_t stride,
+                              const size_t n,
+                              const gsl_fft_complex_wavetable * wavetable,
+                              gsl_fft_complex_workspace * work);
+
+int gsl_fft_complex_inverse (gsl_complex_packed_array data,
+                             const size_t stride,
+                             const size_t n,
+                             const gsl_fft_complex_wavetable * wavetable,
+                             gsl_fft_complex_workspace * work);
+
+int gsl_fft_complex_transform (gsl_complex_packed_array data,
+                               const size_t stride, const size_t n,
+                               const gsl_fft_complex_wavetable * wavetable,
+                               gsl_fft_complex_workspace * work,
+                               const gsl_fft_direction sign);
+
+__END_DECLS
+
+#endif /* __GSL_FFT_COMPLEX_H__ */
diff --git a/gsl/gsl_fft_complex_float.h b/gsl/gsl_fft_complex_float.h
new file mode 100644
index 0000000..d3ff395
--- /dev/null
+++ b/gsl/gsl_fft_complex_float.h
@@ -0,0 +1,139 @@
+/* fft/gsl_fft_complex_float.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_FFT_COMPLEX_FLOAT_H__
+#define __GSL_FFT_COMPLEX_FLOAT_H__
+
+#include <stddef.h>
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_complex.h>
+#include <gsl/gsl_fft.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+/*  Power of 2 routines  */
+
+
+int gsl_fft_complex_float_radix2_forward (gsl_complex_packed_array_float data,
+                                          const size_t stride,
+                                          const size_t n);
+
+int gsl_fft_complex_float_radix2_backward (gsl_complex_packed_array_float data,
+                                           const size_t stride,
+                                           const size_t n);
+
+int gsl_fft_complex_float_radix2_inverse (gsl_complex_packed_array_float data,
+                                          const size_t stride,
+                                          const size_t n);
+
+int gsl_fft_complex_float_radix2_transform (gsl_complex_packed_array_float data,
+                                            const size_t stride,
+                                            const size_t n,
+                                            const gsl_fft_direction sign);
+
+int gsl_fft_complex_float_radix2_dif_forward (gsl_complex_packed_array_float data,
+                                              const size_t stride,
+                                              const size_t n);
+
+int gsl_fft_complex_float_radix2_dif_backward (gsl_complex_packed_array_float data,
+                                               const size_t stride,
+                                               const size_t n);
+
+int gsl_fft_complex_float_radix2_dif_inverse (gsl_complex_packed_array_float data,
+                                              const size_t stride,
+                                              const size_t n);
+
+int gsl_fft_complex_float_radix2_dif_transform (gsl_complex_packed_array_float data,
+                                                const size_t stride,
+                                                const size_t n,
+                                                const gsl_fft_direction sign);
+
+/*  Mixed Radix general-N routines  */
+
+typedef struct
+  {
+    size_t n;
+    size_t nf;
+    size_t factor[64];
+    gsl_complex_float *twiddle[64];
+    gsl_complex_float *trig;
+  }
+gsl_fft_complex_wavetable_float;
+
+typedef struct
+{
+    size_t n;
+    float *scratch;
+}
+gsl_fft_complex_workspace_float;
+
+
+gsl_fft_complex_wavetable_float *gsl_fft_complex_wavetable_float_alloc (size_t n);
+
+void gsl_fft_complex_wavetable_float_free (gsl_fft_complex_wavetable_float * wavetable);
+
+gsl_fft_complex_workspace_float *gsl_fft_complex_workspace_float_alloc (size_t n);
+
+void gsl_fft_complex_workspace_float_free (gsl_fft_complex_workspace_float * workspace);
+
+
+int gsl_fft_complex_float_memcpy (gsl_fft_complex_wavetable_float * dest,
+                               gsl_fft_complex_wavetable_float * src);
+
+
+int gsl_fft_complex_float_forward (gsl_complex_packed_array_float data,
+                                   const size_t stride,
+                                   const size_t n,
+                                   const gsl_fft_complex_wavetable_float * wavetable,
+                                   gsl_fft_complex_workspace_float * work);
+
+int gsl_fft_complex_float_backward (gsl_complex_packed_array_float data,
+                                    const size_t stride,
+                                    const size_t n,
+                                    const gsl_fft_complex_wavetable_float * wavetable,
+                                    gsl_fft_complex_workspace_float * work);
+
+int gsl_fft_complex_float_inverse (gsl_complex_packed_array_float data,
+                                   const size_t stride,
+                                   const size_t n,
+                                   const gsl_fft_complex_wavetable_float * wavetable,
+                                   gsl_fft_complex_workspace_float * work);
+
+int gsl_fft_complex_float_transform (gsl_complex_packed_array_float data,
+                                     const size_t stride, const size_t n,
+                                     const gsl_fft_complex_wavetable_float * wavetable,
+                                     gsl_fft_complex_workspace_float * work,
+                                     const gsl_fft_direction sign);
+
+__END_DECLS
+
+#endif /* __GSL_FFT_COMPLEX_FLOAT_H__ */
+
+
diff --git a/gsl/gsl_fft_halfcomplex.h b/gsl/gsl_fft_halfcomplex.h
new file mode 100644
index 0000000..6751e47
--- /dev/null
+++ b/gsl/gsl_fft_halfcomplex.h
@@ -0,0 +1,86 @@
+/* fft/gsl_fft_halfcomplex.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_FFT_HALFCOMPLEX_H__
+#define __GSL_FFT_HALFCOMPLEX_H__
+
+#include <stddef.h>
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_complex.h>
+#include <gsl/gsl_fft.h>
+#include <gsl/gsl_fft_real.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+int gsl_fft_halfcomplex_radix2_backward (double data[], const size_t stride, const size_t n);
+int gsl_fft_halfcomplex_radix2_inverse (double data[], const size_t stride, const size_t n);
+int gsl_fft_halfcomplex_radix2_transform (double data[], const size_t stride, const size_t n);
+
+typedef struct
+  {
+    size_t n;
+    size_t nf;
+    size_t factor[64];
+    gsl_complex *twiddle[64];
+    gsl_complex *trig;
+  }
+gsl_fft_halfcomplex_wavetable;
+
+gsl_fft_halfcomplex_wavetable * gsl_fft_halfcomplex_wavetable_alloc (size_t n);
+
+void
+gsl_fft_halfcomplex_wavetable_free (gsl_fft_halfcomplex_wavetable * wavetable);
+
+
+int gsl_fft_halfcomplex_backward (double data[], const size_t stride, const size_t n,
+                                  const gsl_fft_halfcomplex_wavetable * wavetable,
+                                  gsl_fft_real_workspace * work);
+
+int gsl_fft_halfcomplex_inverse (double data[], const size_t stride, const size_t n,
+                                 const gsl_fft_halfcomplex_wavetable * wavetable,
+                                 gsl_fft_real_workspace * work);
+
+int gsl_fft_halfcomplex_transform (double data[], const size_t stride, const size_t n,
+                                   const gsl_fft_halfcomplex_wavetable * wavetable,
+                                   gsl_fft_real_workspace * work);
+
+int
+gsl_fft_halfcomplex_unpack (const double halfcomplex_coefficient[],
+                            double complex_coefficient[],
+                            const size_t stride, const size_t n);
+
+int
+gsl_fft_halfcomplex_radix2_unpack (const double halfcomplex_coefficient[],
+                                   double complex_coefficient[],
+                                   const size_t stride, const size_t n);
+
+__END_DECLS
+
+#endif /* __GSL_FFT_HALFCOMPLEX_H__ */
diff --git a/gsl/gsl_fft_halfcomplex_float.h b/gsl/gsl_fft_halfcomplex_float.h
new file mode 100644
index 0000000..e318367
--- /dev/null
+++ b/gsl/gsl_fft_halfcomplex_float.h
@@ -0,0 +1,86 @@
+/* fft/gsl_fft_halfcomplex_float.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_FFT_HALFCOMPLEX_FLOAT_H__
+#define __GSL_FFT_HALFCOMPLEX_FLOAT_H__
+
+#include <stddef.h>
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_complex.h>
+#include <gsl/gsl_fft.h>
+#include <gsl/gsl_fft_real_float.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+int gsl_fft_halfcomplex_float_radix2_backward (float data[], const size_t stride, const size_t n);
+int gsl_fft_halfcomplex_float_radix2_inverse (float data[], const size_t stride, const size_t n);
+int gsl_fft_halfcomplex_float_radix2_transform (float data[], const size_t stride, const size_t n);
+
+typedef struct
+  {
+    size_t n;
+    size_t nf;
+    size_t factor[64];
+    gsl_complex_float *twiddle[64];
+    gsl_complex_float *trig;
+  }
+gsl_fft_halfcomplex_wavetable_float;
+
+
+gsl_fft_halfcomplex_wavetable_float * gsl_fft_halfcomplex_wavetable_float_alloc (size_t n);
+
+void
+gsl_fft_halfcomplex_wavetable_float_free (gsl_fft_halfcomplex_wavetable_float * wavetable);
+
+int gsl_fft_halfcomplex_float_backward (float data[], const size_t stride, const size_t n,
+                                        const gsl_fft_halfcomplex_wavetable_float * wavetable,
+                                        gsl_fft_real_workspace_float * work);
+
+int gsl_fft_halfcomplex_float_inverse (float data[], const size_t stride, const size_t n,
+                                       const gsl_fft_halfcomplex_wavetable_float * wavetable,
+                                       gsl_fft_real_workspace_float * work);
+
+int gsl_fft_halfcomplex_float_transform (float data[], const size_t stride, const size_t n,
+                                         const gsl_fft_halfcomplex_wavetable_float * wavetable,
+                                         gsl_fft_real_workspace_float * work);
+
+int
+gsl_fft_halfcomplex_float_unpack (const float halfcomplex_coefficient[],
+                                  float complex_coefficient[],
+                                  const size_t stride, const size_t n);
+
+int
+gsl_fft_halfcomplex_float_radix2_unpack (const float halfcomplex_coefficient[],
+                                         float complex_coefficient[],
+                                         const size_t stride, const size_t n);
+
+__END_DECLS
+
+#endif /* __GSL_FFT_HALFCOMPLEX_FLOAT_H__ */
diff --git a/gsl/gsl_fft_real.h b/gsl/gsl_fft_real.h
new file mode 100644
index 0000000..e07a604
--- /dev/null
+++ b/gsl/gsl_fft_real.h
@@ -0,0 +1,80 @@
+/* fft/gsl_fft_real.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_FFT_REAL_H__
+#define __GSL_FFT_REAL_H__
+
+#include <stddef.h>
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_complex.h>
+#include <gsl/gsl_fft.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+int gsl_fft_real_radix2_transform (double data[], const size_t stride, const size_t n) ;
+
+typedef struct
+  {
+    size_t n;
+    size_t nf;
+    size_t factor[64];
+    gsl_complex *twiddle[64];
+    gsl_complex *trig;
+  }
+gsl_fft_real_wavetable;
+
+typedef struct
+  {
+    size_t n;
+    double *scratch;
+  }
+gsl_fft_real_workspace;
+
+gsl_fft_real_wavetable * gsl_fft_real_wavetable_alloc (size_t n);
+
+void  gsl_fft_real_wavetable_free (gsl_fft_real_wavetable * wavetable);
+
+gsl_fft_real_workspace * gsl_fft_real_workspace_alloc (size_t n);
+
+void  gsl_fft_real_workspace_free (gsl_fft_real_workspace * workspace);
+
+
+int gsl_fft_real_transform (double data[], const size_t stride, const size_t n,
+                            const gsl_fft_real_wavetable * wavetable,
+                            gsl_fft_real_workspace * work);
+
+
+int gsl_fft_real_unpack (const double real_coefficient[],
+                         double complex_coefficient[],
+                         const size_t stride, const size_t n);
+
+__END_DECLS
+
+#endif /* __GSL_FFT_REAL_H__ */
diff --git a/gsl/gsl_fft_real_float.h b/gsl/gsl_fft_real_float.h
new file mode 100644
index 0000000..7a7732f
--- /dev/null
+++ b/gsl/gsl_fft_real_float.h
@@ -0,0 +1,79 @@
+/* fft/gsl_fft_real_float.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_FFT_REAL_FLOAT_H__
+#define __GSL_FFT_REAL_FLOAT_H__
+
+#include <stddef.h>
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_complex.h>
+#include <gsl/gsl_fft.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+int gsl_fft_real_float_radix2_transform (float data[], const size_t stride, const size_t n) ;
+
+typedef struct
+  {
+    size_t n;
+    size_t nf;
+    size_t factor[64];
+    gsl_complex_float *twiddle[64];
+    gsl_complex_float *trig;
+  }
+gsl_fft_real_wavetable_float;
+
+typedef struct
+  {
+    size_t n;
+    float *scratch;
+  }
+gsl_fft_real_workspace_float;
+
+gsl_fft_real_wavetable_float * gsl_fft_real_wavetable_float_alloc (size_t n);
+
+void  gsl_fft_real_wavetable_float_free (gsl_fft_real_wavetable_float * wavetable);
+
+gsl_fft_real_workspace_float * gsl_fft_real_workspace_float_alloc (size_t n);
+
+void  gsl_fft_real_workspace_float_free (gsl_fft_real_workspace_float * workspace);
+
+int gsl_fft_real_float_transform (float data[], const size_t stride, const size_t n,
+                                  const gsl_fft_real_wavetable_float * wavetable,
+                                  gsl_fft_real_workspace_float * work);
+
+
+int gsl_fft_real_float_unpack (const float real_float_coefficient[],
+                               float complex_coefficient[],
+                               const size_t stride, const size_t n);
+
+__END_DECLS
+
+#endif /* __GSL_FFT_REAL_FLOAT_H__ */
diff --git a/gsl/gsl_inline.h b/gsl/gsl_inline.h
new file mode 100644
index 0000000..fad421a
--- /dev/null
+++ b/gsl/gsl_inline.h
@@ -0,0 +1,67 @@
+/* gsl_inline.h
+ * 
+ * Copyright (C) 2008, 2009 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_INLINE_H__
+#define __GSL_INLINE_H__
+
+/* In recent versiions of GCC, the inline keyword has two different
+   forms: GNU and C99.
+
+   In GNU mode we can use 'extern inline' to make inline functions
+   work like macros.  The function is only inlined--it is never output
+   as a definition in an object file.
+
+   In the new C99 mode 'extern inline' has a different meaning--it
+   causes the definition of the function to be output in each object
+   file where it is used.  This will result in multiple-definition
+   errors on linking.  The 'inline' keyword on its own (without
+   extern) has the same behavior as the original GNU 'extern inline'.
+
+   The C99 style is the default with -std=c99 in GCC 4.3.  
+
+   This header file allows either form of inline to be used by
+   redefining the macros INLINE_DECL and INLINE_FUN.  These are used
+   in the public header files as
+
+        INLINE_DECL double gsl_foo (double x);
+        #ifdef HAVE_INLINE
+        INLINE_FUN double gsl_foo (double x) { return x+1.0; } ;
+        #endif
+   
+*/
+
+#ifdef HAVE_INLINE
+#  if defined(__GNUC_STDC_INLINE__) || defined(GSL_C99_INLINE) || defined(HAVE_C99_INLINE)
+#    define INLINE_DECL static inline  /* use C99 inline */
+#    define INLINE_FUN static inline
+#  else
+#    define INLINE_DECL         /* use GNU extern inline */
+#    define INLINE_FUN extern inline
+#  endif
+#else
+#  define INLINE_DECL /* */
+#endif
+
+/* Range checking conditions in headers do not require any run-time
+   tests of the global variable gsl_check_range.  They are enabled or
+   disabled in user code at compile time with GSL_RANGE_CHECK macro.
+   See also build.h. */
+#define GSL_RANGE_COND(x) (x)
+
+#endif /* __GSL_INLINE_H__ */
diff --git a/gsl/gsl_machine.h b/gsl/gsl_machine.h
new file mode 100644
index 0000000..c44ffc2
--- /dev/null
+++ b/gsl/gsl_machine.h
@@ -0,0 +1,104 @@
+/* Author:  B. Gough and G. Jungman */
+#ifndef __GSL_MACHINE_H__
+#define __GSL_MACHINE_H__
+
+#include <limits.h>
+#include <float.h>
+
+/* magic constants; mostly for the benefit of the implementation */
+
+/* -*-MACHINE CONSTANTS-*-
+ *
+ * PLATFORM: Whiz-O-Matic 9000
+ * FP_PLATFORM: IEEE-Virtual
+ * HOSTNAME: nnn.lanl.gov
+ * DATE: Fri Nov 20 17:53:26 MST 1998
+ */
+#define GSL_DBL_EPSILON        2.2204460492503131e-16
+#define GSL_SQRT_DBL_EPSILON   1.4901161193847656e-08
+#define GSL_ROOT3_DBL_EPSILON  6.0554544523933429e-06
+#define GSL_ROOT4_DBL_EPSILON  1.2207031250000000e-04
+#define GSL_ROOT5_DBL_EPSILON  7.4009597974140505e-04
+#define GSL_ROOT6_DBL_EPSILON  2.4607833005759251e-03
+#define GSL_LOG_DBL_EPSILON   (-3.6043653389117154e+01)
+
+#define GSL_DBL_MIN        2.2250738585072014e-308
+#define GSL_SQRT_DBL_MIN   1.4916681462400413e-154
+#define GSL_ROOT3_DBL_MIN  2.8126442852362996e-103
+#define GSL_ROOT4_DBL_MIN  1.2213386697554620e-77
+#define GSL_ROOT5_DBL_MIN  2.9476022969691763e-62
+#define GSL_ROOT6_DBL_MIN  5.3034368905798218e-52
+#define GSL_LOG_DBL_MIN   (-7.0839641853226408e+02)
+
+#define GSL_DBL_MAX        1.7976931348623157e+308
+#define GSL_SQRT_DBL_MAX   1.3407807929942596e+154
+#define GSL_ROOT3_DBL_MAX  5.6438030941222897e+102
+#define GSL_ROOT4_DBL_MAX  1.1579208923731620e+77
+#define GSL_ROOT5_DBL_MAX  4.4765466227572707e+61
+#define GSL_ROOT6_DBL_MAX  2.3756689782295612e+51
+#define GSL_LOG_DBL_MAX    7.0978271289338397e+02
+
+#define GSL_FLT_EPSILON        1.1920928955078125e-07
+#define GSL_SQRT_FLT_EPSILON   3.4526698300124393e-04
+#define GSL_ROOT3_FLT_EPSILON  4.9215666011518501e-03
+#define GSL_ROOT4_FLT_EPSILON  1.8581361171917516e-02
+#define GSL_ROOT5_FLT_EPSILON  4.1234622211652937e-02
+#define GSL_ROOT6_FLT_EPSILON  7.0153878019335827e-02
+#define GSL_LOG_FLT_EPSILON   (-1.5942385152878742e+01)
+
+#define GSL_FLT_MIN        1.1754943508222875e-38
+#define GSL_SQRT_FLT_MIN   1.0842021724855044e-19
+#define GSL_ROOT3_FLT_MIN  2.2737367544323241e-13
+#define GSL_ROOT4_FLT_MIN  3.2927225399135965e-10
+#define GSL_ROOT5_FLT_MIN  2.5944428542140822e-08
+#define GSL_ROOT6_FLT_MIN  4.7683715820312542e-07
+#define GSL_LOG_FLT_MIN   (-8.7336544750553102e+01)
+
+#define GSL_FLT_MAX        3.4028234663852886e+38
+#define GSL_SQRT_FLT_MAX   1.8446743523953730e+19
+#define GSL_ROOT3_FLT_MAX  6.9814635196223242e+12
+#define GSL_ROOT4_FLT_MAX  4.2949672319999986e+09
+#define GSL_ROOT5_FLT_MAX  5.0859007855960041e+07
+#define GSL_ROOT6_FLT_MAX  2.6422459233807749e+06
+#define GSL_LOG_FLT_MAX    8.8722839052068352e+01
+
+#define GSL_SFLT_EPSILON        4.8828125000000000e-04
+#define GSL_SQRT_SFLT_EPSILON   2.2097086912079612e-02
+#define GSL_ROOT3_SFLT_EPSILON  7.8745065618429588e-02
+#define GSL_ROOT4_SFLT_EPSILON  1.4865088937534013e-01
+#define GSL_ROOT5_SFLT_EPSILON  2.1763764082403100e-01
+#define GSL_ROOT6_SFLT_EPSILON  2.8061551207734325e-01
+#define GSL_LOG_SFLT_EPSILON   (-7.6246189861593985e+00)
+
+/* !MACHINE CONSTANTS! */
+
+
+/* a little internal backwards compatibility */
+#define GSL_MACH_EPS  GSL_DBL_EPSILON
+
+
+
+/* Here are the constants related to or derived from
+ * machine constants. These are not to be confused with
+ * the constants that define various precision levels
+ * for the precision/error system.
+ *
+ * This information is determined at configure time
+ * and is platform dependent. Edit at your own risk.
+ *
+ * PLATFORM: WHIZ-O-MATIC
+ * CONFIG-DATE: Thu Nov 19 19:27:18 MST 1998
+ * CONFIG-HOST: nnn.lanl.gov
+ */
+
+/* machine precision constants */
+/* #define GSL_MACH_EPS         1.0e-15 */
+#define GSL_SQRT_MACH_EPS       3.2e-08
+#define GSL_ROOT3_MACH_EPS      1.0e-05
+#define GSL_ROOT4_MACH_EPS      0.000178
+#define GSL_ROOT5_MACH_EPS      0.00100
+#define GSL_ROOT6_MACH_EPS      0.00316
+#define GSL_LOG_MACH_EPS       (-34.54)
+
+
+#endif /* __GSL_MACHINE_H__ */
diff --git a/gsl/gsl_math.h b/gsl/gsl_math.h
new file mode 100644
index 0000000..2d09df1
--- /dev/null
+++ b/gsl/gsl_math.h
@@ -0,0 +1,164 @@
+/* gsl_math.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 Gerard Jungman, Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_MATH_H__
+#define __GSL_MATH_H__
+#include <math.h>
+#include <gsl/gsl_sys.h>
+#include <gsl/gsl_inline.h>
+#include <gsl/gsl_machine.h>
+#include <gsl/gsl_precision.h>
+#include <gsl/gsl_nan.h>
+#include <gsl/gsl_pow_int.h>
+#include <gsl/gsl_minmax.h>
+
+#ifndef M_E
+#define M_E        2.71828182845904523536028747135      /* e */
+#endif
+
+#ifndef M_LOG2E
+#define M_LOG2E    1.44269504088896340735992468100      /* log_2 (e) */
+#endif
+
+#ifndef M_LOG10E
+#define M_LOG10E   0.43429448190325182765112891892      /* log_10 (e) */
+#endif
+
+#ifndef M_SQRT2
+#define M_SQRT2    1.41421356237309504880168872421      /* sqrt(2) */
+#endif
+
+#ifndef M_SQRT1_2
+#define M_SQRT1_2  0.70710678118654752440084436210      /* sqrt(1/2) */
+#endif
+
+
+#ifndef M_SQRT3
+#define M_SQRT3    1.73205080756887729352744634151      /* sqrt(3) */
+#endif
+
+#ifndef M_PI
+#define M_PI       3.14159265358979323846264338328      /* pi */
+#endif
+
+#ifndef M_PI_2
+#define M_PI_2     1.57079632679489661923132169164      /* pi/2 */
+#endif
+
+#ifndef M_PI_4
+#define M_PI_4     0.78539816339744830961566084582     /* pi/4 */
+#endif
+
+#ifndef M_SQRTPI
+#define M_SQRTPI   1.77245385090551602729816748334      /* sqrt(pi) */
+#endif
+
+#ifndef M_2_SQRTPI
+#define M_2_SQRTPI 1.12837916709551257389615890312      /* 2/sqrt(pi) */
+#endif
+
+#ifndef M_1_PI
+#define M_1_PI     0.31830988618379067153776752675      /* 1/pi */
+#endif
+
+#ifndef M_2_PI
+#define M_2_PI     0.63661977236758134307553505349      /* 2/pi */
+#endif
+
+#ifndef M_LN10
+#define M_LN10     2.30258509299404568401799145468      /* ln(10) */
+#endif
+
+#ifndef M_LN2
+#define M_LN2      0.69314718055994530941723212146      /* ln(2) */
+#endif
+
+#ifndef M_LNPI
+#define M_LNPI     1.14472988584940017414342735135      /* ln(pi) */
+#endif
+
+#ifndef M_EULER
+#define M_EULER    0.57721566490153286060651209008      /* Euler constant */
+#endif
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+/* other needlessly compulsive abstractions */
+
+#define GSL_IS_ODD(n)  ((n) & 1)
+#define GSL_IS_EVEN(n) (!(GSL_IS_ODD(n)))
+#define GSL_SIGN(x)    ((x) >= 0.0 ? 1 : -1)
+
+/* Return nonzero if x is a real number, i.e. non NaN or infinite. */
+#define GSL_IS_REAL(x) (gsl_finite(x))
+
+/* Definition of an arbitrary function with parameters */
+
+struct gsl_function_struct 
+{
+  double (* function) (double x, void * params);
+  void * params;
+};
+
+typedef struct gsl_function_struct gsl_function ;
+
+#define GSL_FN_EVAL(F,x) (*((F)->function))(x,(F)->params)
+
+/* Definition of an arbitrary function returning two values, r1, r2 */
+
+struct gsl_function_fdf_struct 
+{
+  double (* f) (double x, void * params);
+  double (* df) (double x, void * params);
+  void (* fdf) (double x, void * params, double * f, double * df);
+  void * params;
+};
+
+typedef struct gsl_function_fdf_struct gsl_function_fdf ;
+
+#define GSL_FN_FDF_EVAL_F(FDF,x) (*((FDF)->f))(x,(FDF)->params)
+#define GSL_FN_FDF_EVAL_DF(FDF,x) (*((FDF)->df))(x,(FDF)->params)
+#define GSL_FN_FDF_EVAL_F_DF(FDF,x,y,dy) (*((FDF)->fdf))(x,(FDF)->params,(y),(dy))
+
+
+/* Definition of an arbitrary vector-valued function with parameters */
+
+struct gsl_function_vec_struct 
+{
+  int (* function) (double x, double y[], void * params);
+  void * params;
+};
+
+typedef struct gsl_function_vec_struct gsl_function_vec ;
+
+#define GSL_FN_VEC_EVAL(F,x,y) (*((F)->function))(x,y,(F)->params)
+
+__END_DECLS
+
+#endif /* __GSL_MATH_H__ */
diff --git a/gsl/gsl_minmax.h b/gsl/gsl_minmax.h
new file mode 100644
index 0000000..0d9a836
--- /dev/null
+++ b/gsl/gsl_minmax.h
@@ -0,0 +1,102 @@
+/* gsl_minmax.h
+ * 
+ * Copyright (C) 2008 Gerard Jungman, Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_MINMAX_H__
+#define __GSL_MINMAX_H__
+#include <gsl/gsl_inline.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+/* Define MAX and MIN macros/functions if they don't exist. */
+
+/* plain old macros for general use */
+#define GSL_MAX(a,b) ((a) > (b) ? (a) : (b))
+#define GSL_MIN(a,b) ((a) < (b) ? (a) : (b))
+
+/* function versions of the above, in case they are needed */
+double gsl_max (double a, double b);
+double gsl_min (double a, double b);
+
+/* inline-friendly strongly typed versions */
+#ifdef HAVE_INLINE
+
+INLINE_FUN int GSL_MAX_INT (int a, int b);
+INLINE_FUN int GSL_MIN_INT (int a, int b);
+INLINE_FUN double GSL_MAX_DBL (double a, double b);
+INLINE_FUN double GSL_MIN_DBL (double a, double b);
+INLINE_FUN long double GSL_MAX_LDBL (long double a, long double b);
+INLINE_FUN long double GSL_MIN_LDBL (long double a, long double b);
+
+INLINE_FUN int
+GSL_MAX_INT (int a, int b)
+{
+  return GSL_MAX (a, b);
+}
+
+INLINE_FUN int
+GSL_MIN_INT (int a, int b)
+{
+  return GSL_MIN (a, b);
+}
+
+INLINE_FUN double
+GSL_MAX_DBL (double a, double b)
+{
+  return GSL_MAX (a, b);
+}
+
+INLINE_FUN double
+GSL_MIN_DBL (double a, double b)
+{
+  return GSL_MIN (a, b);
+}
+
+INLINE_FUN long double
+GSL_MAX_LDBL (long double a, long double b)
+{
+  return GSL_MAX (a, b);
+}
+
+INLINE_FUN long double
+GSL_MIN_LDBL (long double a, long double b)
+{
+  return GSL_MIN (a, b);
+}
+#else
+#define GSL_MAX_INT(a,b)   GSL_MAX(a,b)
+#define GSL_MIN_INT(a,b)   GSL_MIN(a,b)
+#define GSL_MAX_DBL(a,b)   GSL_MAX(a,b)
+#define GSL_MIN_DBL(a,b)   GSL_MIN(a,b)
+#define GSL_MAX_LDBL(a,b)  GSL_MAX(a,b)
+#define GSL_MIN_LDBL(a,b)  GSL_MIN(a,b)
+#endif /* HAVE_INLINE */
+
+__END_DECLS
+
+#endif /* __GSL_POW_INT_H__ */
diff --git a/gsl/gsl_mode.h b/gsl/gsl_mode.h
new file mode 100644
index 0000000..c8e5d55
--- /dev/null
+++ b/gsl/gsl_mode.h
@@ -0,0 +1,88 @@
+/* gsl_mode.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004 Gerard Jungman
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+/* Author:  B. Gough and G. Jungman */
+
+#ifndef __GSL_MODE_H__
+#define __GSL_MODE_H__
+#include <gsl/gsl_inline.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+
+/* Some functions can take a mode argument. This
+ * is a rough method to do things like control
+ * the precision of the algorithm. This mainly
+ * occurs in special functions, but we figured
+ * it was ok to have a general facility.
+ *
+ * The mode type is 32-bit field. Most of
+ * the fields are currently unused. Users
+ * '|' various predefined constants to get
+ * a desired mode.
+ */
+typedef unsigned int gsl_mode_t;
+
+
+/* Here are the predefined constants.
+ * Note that the precision constants
+ * are special because they are used
+ * to index arrays, so do not change
+ * them. The precision information is
+ * in the low order 3 bits of gsl_mode_t
+ * (the third bit is currently unused).
+ */
+
+/* Note that "0" is double precision,
+ * so that you get that by default if
+ * you forget a flag.
+ */
+#define GSL_PREC_DOUBLE  0
+#define GSL_PREC_SINGLE  1
+#define GSL_PREC_APPROX  2
+
+#ifdef HAVE_INLINE
+INLINE_FUN unsigned int GSL_MODE_PREC(gsl_mode_t mt);
+
+INLINE_FUN unsigned int
+GSL_MODE_PREC(gsl_mode_t mt)
+{ return  (mt & (unsigned int)7); }
+#else  /* HAVE_INLINE */
+#define GSL_MODE_PREC(mt) ((mt) & (unsigned int)7)
+#endif /* HAVE_INLINE */
+
+
+/* Here are some predefined generic modes.
+ */
+#define GSL_MODE_DEFAULT  0
+
+
+__END_DECLS
+
+#endif /* __GSL_MODE_H__ */
diff --git a/gsl/gsl_nan.h b/gsl/gsl_nan.h
new file mode 100644
index 0000000..5cb52ef
--- /dev/null
+++ b/gsl/gsl_nan.h
@@ -0,0 +1,45 @@
+/* gsl_nan.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_NAN_H__
+#define __GSL_NAN_H__
+
+#ifdef INFINITY
+# define GSL_POSINF INFINITY
+# define GSL_NEGINF (-INFINITY)
+#elif defined(HUGE_VAL)
+# define GSL_POSINF HUGE_VAL
+# define GSL_NEGINF (-HUGE_VAL)
+#else
+# define GSL_POSINF (gsl_posinf())
+# define GSL_NEGINF (gsl_neginf())
+#endif
+
+#ifdef NAN
+# define GSL_NAN NAN
+#elif defined(INFINITY)
+# define GSL_NAN (INFINITY/INFINITY)
+#else
+# define GSL_NAN (gsl_nan())
+#endif
+
+#define GSL_POSZERO (+0.0)
+#define GSL_NEGZERO (-0.0)
+
+#endif /* __GSL_NAN_H__ */
diff --git a/gsl/gsl_pow_int.h b/gsl/gsl_pow_int.h
new file mode 100644
index 0000000..6aa01fb
--- /dev/null
+++ b/gsl/gsl_pow_int.h
@@ -0,0 +1,61 @@
+/* gsl_pow_int.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 Gerard Jungman, Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_POW_INT_H__
+#define __GSL_POW_INT_H__
+#include <gsl/gsl_inline.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+INLINE_DECL double gsl_pow_2(const double x);
+INLINE_DECL double gsl_pow_3(const double x);
+INLINE_DECL double gsl_pow_4(const double x);
+INLINE_DECL double gsl_pow_5(const double x);
+INLINE_DECL double gsl_pow_6(const double x);
+INLINE_DECL double gsl_pow_7(const double x);
+INLINE_DECL double gsl_pow_8(const double x);
+INLINE_DECL double gsl_pow_9(const double x);
+
+#ifdef HAVE_INLINE
+INLINE_FUN double gsl_pow_2(const double x) { return x*x;   }
+INLINE_FUN double gsl_pow_3(const double x) { return x*x*x; }
+INLINE_FUN double gsl_pow_4(const double x) { double x2 = x*x;   return x2*x2;    }
+INLINE_FUN double gsl_pow_5(const double x) { double x2 = x*x;   return x2*x2*x;  }
+INLINE_FUN double gsl_pow_6(const double x) { double x2 = x*x;   return x2*x2*x2; }
+INLINE_FUN double gsl_pow_7(const double x) { double x3 = x*x*x; return x3*x3*x;  }
+INLINE_FUN double gsl_pow_8(const double x) { double x2 = x*x;   double x4 = x2*x2; return x4*x4; }
+INLINE_FUN double gsl_pow_9(const double x) { double x3 = x*x*x; return x3*x3*x3; }
+#endif
+
+double gsl_pow_int(double x, int n);
+double gsl_pow_uint(double x, unsigned int n);
+
+__END_DECLS
+
+#endif /* __GSL_POW_INT_H__ */
diff --git a/gsl/gsl_precision.h b/gsl/gsl_precision.h
new file mode 100644
index 0000000..97a204e
--- /dev/null
+++ b/gsl/gsl_precision.h
@@ -0,0 +1,66 @@
+/* gsl_precision.h
+ * 
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+/* Author:  B. Gough and G. Jungman */
+
+#ifndef __GSL_PRECISION_H__
+#define __GSL_PRECISION_H__
+#include <gsl/gsl_types.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+__BEGIN_DECLS
+
+
+/* A type for the precision indicator.
+ * This is mainly for pedagogy.
+ */
+typedef  unsigned int  gsl_prec_t;
+
+
+/* The number of precision types.
+ * Remember that precision-mode
+ * can index an array.
+ */
+#define _GSL_PREC_T_NUM 3
+
+
+/* Arrays containing derived
+ * precision constants for the
+ * different precision levels.
+ */
+GSL_VAR const double gsl_prec_eps[];
+GSL_VAR const double gsl_prec_sqrt_eps[];
+GSL_VAR const double gsl_prec_root3_eps[];
+GSL_VAR const double gsl_prec_root4_eps[];
+GSL_VAR const double gsl_prec_root5_eps[];
+GSL_VAR const double gsl_prec_root6_eps[];
+
+
+__END_DECLS
+
+#endif /* __GSL_PRECISION_H__ */
diff --git a/gsl/gsl_types.h b/gsl/gsl_types.h
new file mode 100644
index 0000000..0330f55
--- /dev/null
+++ b/gsl/gsl_types.h
@@ -0,0 +1,41 @@
+/* gsl_types.h
+ * 
+ * Copyright (C) 2001, 2007 Brian Gough
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GSL_TYPES_H__
+#define __GSL_TYPES_H__
+
+#ifndef GSL_VAR
+
+#ifdef WIN32
+#  ifdef GSL_DLL
+#    ifdef DLL_EXPORT
+#      define GSL_VAR extern __declspec(dllexport)
+#    else
+#      define GSL_VAR extern __declspec(dllimport)
+#    endif
+#  else
+#    define GSL_VAR extern
+#  endif
+#else
+#  define GSL_VAR extern
+#endif
+
+#endif
+
+#endif /* __GSL_TYPES_H__ */
diff --git a/gsl/gsl_version.h b/gsl/gsl_version.h
new file mode 100644
index 0000000..d5337be
--- /dev/null
+++ b/gsl/gsl_version.h
@@ -0,0 +1,26 @@
+#ifndef __GSL_VERSION_H__
+#define __GSL_VERSION_H__
+
+#include <gsl/gsl_types.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+__BEGIN_DECLS
+
+
+#define GSL_VERSION "2.7"
+#define GSL_MAJOR_VERSION 2
+#define GSL_MINOR_VERSION 7
+
+GSL_VAR const char * gsl_version;
+
+__END_DECLS
+
+#endif /* __GSL_VERSION_H__ */
